# 10/18

# [목차]📝

[1. RDB](#rdb)

[2. comment기능 정리](#comment기능-정리)

[3. comment 삭제 기능 정리](#comment-삭제-기능-정리)

<br>

## RDB

- 데이터를 테이블, 행, 열 등으로 나누어 구조화하는 방식
- RDB의 모든 테이블에는 행에서 고유하게 식별 가능한 기본 키라는 속성이 있으며, 외래 키를 사용하여 각 행에서 서로 다른 테이블 간의 관계를 만드는데 사용할 수 있음
- RDB에서의 관계

```py
1:1 (프로필)
- 한 테이블의 레코드 하나가 다른 테이블의 레코드 단 한 개와 관련된 경우
1:N (댓글)
- 한 테이블의 0개 이상의 레코드가 다른 테이블의 레코드 한 개와 관련된 경우
M:N
- 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우
```

- Foreign Key

```py
외래 키의 값이 부모 테이블의 기본 키 일 필요는 없지만, 유일한 값이어야 함
```

<br>

### 1:N (Article - Comment)

```py
가장 먼저 모델 관계 설정
게시판의 게시글과 1:N 관계를 나타낼 수 있는 댓글 구현
1:N 관계에서 댓글을 담당할 Article 모델은 1, Comment 모델은 N이 될 것
- 게시글(1)은 여러 개의 댓글(N)을 가진다.
- 게시글(1)은 댓글을 가지지 않을 수도 있다.
- 댓글은 하나의 게시글에 속한다.
```

- ForeignKey arguments - on_delete

```py
- 외래 키가 참조하는 객체가 사라졌을 때,
외래 키를 가진 객체를 어떻게 처리할 지를 정의
- 데이터 무결성을 위해서 매우 중요한 설정
```

- Comment 모델 정의

```py
외래 키 필드는 ForeignKey 클래스를 작성하는 위치와 관계없이 필드의 마지막에 작성됨
ForeignKey() 클래스의 인스턴스 이름은 참조하는 모델 클래스 이름의 단수형(소문자)로 작성하는 것을 권장

class Comment(models.Model):
  content = models.TextField()
  created_at = models.DateTimeField(auto_now_add=True)
  article = models.ForeignKey(Article, on_delete=models.CASCADE) # Article이 위에 정의되야 하는데 만약에 위에서 정의 할 수 없으면 ''로 감싸서 문자로 취급 가능
  ex)
  article = models.ForeignKey("Article", on_delete=models.CASCADE)
```

```py
# 게시글 13번에 내용이 111인 댓글을 생성하는 코드
Comment.objects.create(content='111', article=article)
# T에 뿌려주려면
{% for comment in article.comment_set.all %}
{{ comment.content }}
{% endfor %}

# views.py
def comment_create(request, pk):
  article = Article.objects.get(pk=pk)
  comment_form = CommentForm(request.POST)
  if comment_form.is_valid():
    comment = comment_form.save(commit=False)
    comment.article = article
    comment.save()
  return redirect('articles:detail', article.pk)
```

## Comment기능 정리

1. 먼저 Comment Model을 정의

```py
# models.py
class Comment(models.Model):
    content = models.TextField(max_length=80)
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    # article의 Article과 on_delete=models.CASCADE를 가짐
```

2. 정의한 모델을 ModelForm으로 넘겨줌

```py
from .models import Comment

class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment
        fields = [
            "content",
        ]
```

3. 메마마(makemigration, migrate)

4. urls.py 에서 path 정의

```py
from . import views

app_name = "articles"

urlpatterns = [
  path("<int:pk>/comments/", views.comment_create, name="comment_create")
]
```

5. views.py에서 comment_create 정의하고, 내용을 보내주고 싶은곳으로 redirect

```py
def comment_create(request, pk):
  article = Article.objects.get(pk=pk)
  comment_form = CommentForm(request.POST) # html에서 POST로 온 요청 받음
  if comment_form.is_vaild():
    comment = comment_form.save(commit=False)
    comment.article = article
    comment.save()
  return redirect("articles:detail", article.pk)
```

6. detail.html에서 받아오기.

```html
<!-- 먼저 제출할 폼을 설정 -->
<form action="{% url 'articles:comment_create' article.pk %}" method="POST">
  {% csrf_token %} {% bootstrap_form comment_form layout="inline"%} {%
  bootstrap_button button_type="submit" content="OK" %}
</form>

{% for comment in comments %} {{ comment.content }} {% empty %}
<p>댓글이 없어요 ㅠ_ㅠ</p>
{% endfor %}
```

## Comment 삭제 기능 정리

1. urls에서 path설정

```py
# urls.py
path("<ind:article_pk>/comments/<int:comment_pk>/delete/", views.comment_delete, name="comment_delete",)
```

2. views.py에서 def 정의

```py
# articel_pk와 comment_pk가 둘다 필요
def comment_delete(request, article_pk, comment_pk):
  Comment.objects.get(pk=comment_pk).delete() #pk=comment_pk가 일치하는 것을 삭제
  return redirect("articles:detail", article_pk)
```

3. detail.html에서 렌더링

```html
{% for comment in comments %} {{ comment.content }}
<!-- form을 제출할 때 article.pk와 comment.pk를 같이 제출 -->
<form
  action="{% url 'articles:comment_delete' article.pk comment.pk %}"
  method="POST"
>
  {% csrf_token %}
  <input type="submit" value="DELETE" />
</form>
```

-

* 댓글 개수 출력하기

```py
# DTL filter - length 사용
{{ comments|length}}
# Queryset API - count() 사용
{{ comments.count }}
{{ article.comment_set.count }}
```
