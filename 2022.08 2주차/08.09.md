# 8/9

# 🕓 9:00 ~ 6:00

## ✅ 그래프

### 그래프에 대한 이해

```py
정점(Vertex)과 이를 연결하는 간선(Edge)들의 집합으로 이루어진 비선형 자료구조
ex) 지하철 노선, 소셜 네트워크
```

### **그래프 관련 용어**

```py
정점: 간선으로 연결되는 객체이며, 노드(Node)라고 함
간선: 정점 간의 관계(연결)를 표현하는 선을 의미
경로: 시작 정점부터 도착 정점까지 거치는 정점을 나열한 것을 의미
인접: 두 개의 정점이 하나의 간선으로 직접 연결된 상태를 의미
```

### 그래프의 종류

### **무방향 그래프(Undirected graph)**

```py
간선의 "방향이 없는" 가장 일반적인 그래프
간선을 통해 양방향의 정점 이동 가능
"차수(Degree)": 하나의 정점에 연결된 간선의 개수
모든 정점의 차수의 합 = 간선 수 * 2
```

### **유방향 그래프(Directed graph)**

```py
간선의 "방향이 있는" 그래프
간선의 방향이 가리키는 정점으로 이동 가능
"차수(Degree)": 진입 차수와 진출 차수로 나누어짐
- 진입차수: 외부 정점에서 한 정점으로 들어오는 간선의 수
- 진출차수: 한 정점에서 외부 정점으로 나가는 간선의 수
```

### **그래프를 실제 문제에서 코드로 표현하는 방법**

```py
graph = {
    0: [1,2],
    1: [0,3,4],
    2: [0,4,5],
    3: [1],
    4: [1,2,6],
    5: [2],
    6: [4]
}

graph = [
    [1,2],
    [0,3,4],
    [0,4,5],
    [1],
    [1,2,6],
    [2],
    [4]
]
```

### **인접 행렬**

```py
두 정점을 연결하는 "간선이 없으면 0, 있으면 1" 을 가지는 "행렬"로 표현하는 방식
edges = [
    [0, 1],
    [0, 2],
    [1, 3],
    [2, 4],
    [2, 5],
    [4, 6]
]

n = 7

# n x n 행렬 초기화 [0으로 초기화]
matrix = [[0] * n for _ in range(n)]

for _ in range(m):
    v1, v2 = map(int, input().split())
    graph[v1][v2] = 1
    graph[v2][v1] = 1
```

### **인접 행렬 vs 인접 리스트**

```py
"인접 행렬"은 직관적이고 만들기 편하지만, 불필요한 공간이 낭비된다.
"인접 리스트"는 연결된 정점만 저장하여 효율적이므로 자주 사용된다.
# 인접 행렬
edges = [
    [0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0]
    [0,0,0,0,0,0,0]
]
# 인접 리스트
edges = [
    [0, 1],
    [0, 2],
    [1, 3],
    [2, 4],
    [2, 5],
    [4, 6]
]
```

## ✅ 실습 문제

[✏️01. 모음의 개수](./CodingTest2/01.%EB%AA%A8%EC%9D%8C%EC%9D%98%20%EA%B0%9C%EC%88%98.py)  
[✏️02. 사분면](./CodingTest2/02.%EC%82%AC%EB%B6%84%EB%A9%B4.py)  
[✏️03. 가장 많은 글자](./CodingTest2/03.%EA%B0%80%EC%9E%A5%20%EB%A7%8E%EC%9D%80%20%EA%B8%80%EC%9E%90.py)  
[✏️04. 가장 큰 김민수](./CodingTest2/04.%EA%B0%80%EC%9E%A5%20%ED%81%B0%20%EA%B9%80%EB%AF%BC%EC%88%98.py)  
[✏️05. 몬스터 트랙](.//CodingTest2/05.%EB%AA%AC%EC%8A%A4%ED%84%B0%20%ED%8A%B8%EB%9F%AD.py)
