# 9/23

# [React] React Quick Start 📝

## **Ref와 DOM** 💭

- Ref는 render 메서드에서 생성된 DOM 노드나 React 엘리먼트에 접근하는 방법을 제공

### Ref를 사용해야 할 때 💡

```js
- 포커스, 텍스트 선택영역, 혹은 미디어의 재생을 관리할 때.

- 애니메이션을 직접적으로 실행시킬 때.

- 서드 파티 DOM 라이브러리를 React와 같이 사용할 때.
```

### Ref 생성하기💡

- Ref는 React.createRef()를 통해 생성

```js
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}
```

### DOM 엘리먼트에 Ref 사용하기 💡

```js
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // textInput DOM 엘리먼트를 저장하기 위한 ref를 생성합니다.
    this.textInput = React.createRef();
    this.focusTextInput = this.focusTextInput.bind(this);
  }

  focusTextInput() {
    // DOM API를 사용하여 명시적으로 text 타입의 input 엘리먼트를 포커스합니다.
    // 주의: 우리는 지금 DOM 노드를 얻기 위해 "current" 프로퍼티에 접근하고 있습니다.
    this.textInput.current.focus();
  }

  render() {
    // React에게 우리가 text 타입의 input 엘리먼트를
    // 우리가 생성자에서 생성한 `textInput` ref와 연결하고 싶다고 이야기합니다.
    return (
      <div>
        <input type="text" ref={this.textInput} />
        <input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```

### 클래스 컴포넌트에 ref 사용하기 💡

```js
class AutoFocusTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }

  componentDidMount() {
    this.textInput.current.focusTextInput();
  }

  render() {
    return <CustomTextInput ref={this.textInput} />;
  }
}
```

## **콜백 ref** 💭

- 콜백 ref를 사용할 때에는 ref 어트리뷰트에 React.createRef()를 통해 생성된 ref를 전달하는 대신, 함수를 전달

```js
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);

    this.textInput = null;

    this.setTextInputRef = (element) => {
      this.textInput = element;
    };

    this.focusTextInput = () => {
      // DOM API를 사용하여 text 타입의 input 엘리먼트를 포커스합니다.
      if (this.textInput) this.textInput.focus();
    };
  }

  componentDidMount() {
    // 마운트 되었을 때 자동으로 text 타입의 input 엘리먼트를 포커스합니다.
    this.focusTextInput();
  }

  render() {
    // text 타입의 input 엘리먼트의 참조를 인스턴스의 프로퍼티
    // (예를 들어`this.textInput`)에 저장하기 위해 `ref` 콜백을 사용합니다.
    return (
      <div>
        <input type="text" ref={this.setTextInputRef} />
        <input
          type="button"
          value="Focus the text input"
          onClick={this.focusTextInput}
        />
      </div>
    );
  }
}
```

# ✅ (React) 문서 공부

https://ko.reactjs.org/docs/hello-world.html

## 📑 리스트와 Key

- JavaScript 에서의 리스트 변환

```jsx
map() 함수를 이용하여 numbers 배열의 값을 두배로 만든 후 map()에서 반환하는 새 배열을 doubled 변수에 할당하고 로그를 확인하는 코드

const numbers =[1,2,3,4,5];
const doubled = numbers.map((number) => number * 2);
console.log(doubled);
// [2, 4, 6, 8, 10]
```

- 여러개의 컴포넌트 렌더링 하기

```jsx
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) => <li>{number}</li>);

그러면 ul 엘리먼트 안에 전체 listItems 배열을 포함할 수 있음
<ul>{listItems}</ul>
```

- 일반적으로 컴포넌트 안에서 리스트를 렌더링

```jsx
function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) => <li>{number}</li>);
  return <ul>{listItems}</ul>;
}

const numbers = [1, 2, 3, 4, 5];
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<NumberList numbers={numbers} />);
```

- Key로 컴포넌트 추출하기

```jsx
function ListItem(props) {
  // 여기에는 key를 지정할 필요가 없음
  return <li>{props.value}</li>;
}

function NumberList(props) {
  const numbers = props.numbers;
  const listItems = numbers.map((number) => (
    // 배열 안에 key를 지정해야 함
    <ListItem key={number.toString()} value={number} />
  ));
  return <ul>{listItems}</ul>;
}
```

## 📑 폼 form

- HTML 폼 엘리먼트는 폼 엘리먼트 자체가 내부 상태를 가지기 떄문에, React의 다른 DOM 엘리먼트와 다르게 동작.

- 제어 컴포넌트 (Comtrolled Component)

```jsx
React에서는 변경할 수 있는 state가 일반적으로 컴포넌트의 state 속성에 유지되며 setState()에 의해 업데이트 됨.

React state를 'single source of truth'로 만들어 두 요소를 결합 할 수 있음. 이러한 방식으로 React에 의해 값이 제어되는 입력 폼 엘리먼트를 "제어 컴포넌트"라고 함

- 예
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: ''};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

## 📑 비제어 컴포넌트

```jsx
클래스 컴포넌트 일 때 ref를 사용하는 방법

import {createRef} from "react"
```

```jsx
import { useRef } from "react";
```

## 🔎 내가 생각하는 중요한 기술

- React에서 DOM을 선택해 조작하기 위해 Ref를 사용하는데 Ref를 잘 활용하면 다이나믹한 홈페이지를 만들 수 있을 것 같다.

- 사용자와의 인터렉티브를 위해서 Ref 사용에 익숙해져야 될 것 같다.

## 💎 느낀점

- 정말 많이 부족하다는 걸 느낀다. 리액트를 공부한지는 3일정도 밖에 안됐지만, 얼른 익숙해지고 싶다는 생각이 든다.

- 지금까지는 HTML에서 ID값을 부여하거나 Class를 통해서 조작했는데, 리액트에서 Ref를 통해 DOM을 조작하면 더 편한가? 하는 생각이 든다.
