# 9/16

# [JS] JavaScript 📝

## **ECMA Script** 💭

- 코딩 스타일의 핵심은 합의된 원칙과 일관성
- 코딩 스타일은 코드의 품질에 직결되는 중요한 요소

### 변수와 식별자 💡

```py
- 식별자는 변수를 구분할 수 잇는 변수명을 말함

- 식별자는 반드시 문자, 달러 또는 밑줄로 시작
```

### 데이터 타입 💡

```py
- 자바스크립트의 모든 값은 특정한 데이터 타입을 가짐

- 크게 "원시타입"과 "참조타입"으로 분류됨
```

## **null** 💭

```js
변수의 값이 없음을 의도적으로 표현할 때 사용하는 데이터 타입

null 타입과 typeof 연산자
```

### 일치 비교 연산자 💡

```py
- 두 연산자가 같은 값으로 평가되는지 비교 후 boolean 값을 반환

- 엄격한 비교가 이뤄지며 암묵적 타입 변환이 밠애하지 않음
```

### 논리연산자 💡

```js
- and 연산은 &&
- or 연산은 ||
- not 연산은 !
```

### 삼항 연산자 💡

```js
console.log(true ? 1 : 2) 1은 true일때 값
```

```js
const a = document.createElement("a");
a.innerText = "실라버스";
body.appendChild(a);
a.setAttribute("href", "URL주소");
```

## **조건문** 💭

- if statement 예시

```js
if (nation === 'Korea') {
    console.log('안녕하세요')
} else if ()
```

- swich statement

```js
swich(expression) {
    case 'first value': {
        [break]
    }
} case 'second value': {

}
```

## **반복문** 💭

```js
for (let i = 0; i < 6; i++) {
  console.log(i); // 0, 1, 2, 3, 4, 5
}

for (variable in object) {
  console.log(variable); // object
}
// of는 객체를 이용시 오류(리스트용)
for (let fruit of fruits) {
  fruit = fruit + "!";
  console.log(fruit);
}
```

## **함수** 💭

```js
- 참조 타입 중 하나로서 funtion 타입에 속함

- JavaScript 에서 함수를 정의하는 방법은 주로 2가지로 구분.
```

- 함수 표현식

```js
// 함수 자체를 변수에 저장하는 느낌
const name = function (args) {
  // do something
};
```

- **_매개변수와 인자의 개수 불일치 허용_**

```js
const twoArgs = function (arg1, arg2) {
    return [arg1, arg2]

twoArgs(1,2,3) // [1,2]
```

## **Arrow Function** 💭

```js
const arrow4 = (name) => `hello, ${name}`;
```

## **배열(Arrays)** 💭

```js
- 키와 속성들을 담고 있는 참조 타입의 객체

- 배열의 길이는 array.length로 가능
```

- join

```js
array.join([separator])
- 배열의 모든 요소를 연결하여 반환

- separator는 선택적으로 지정 가능하며, 생략 시 쉼표를 기본 값으로 사용
```

## **객체(Objects)** 💭

```js
- 객체는 속성의 집합이며, 중괄호 내부에 key와 value의 쌍으로 표현

- 객체 요소 접근은 점 또는 대괄호로 가능
```

# ✅ 문서 공부

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach

## 📑 변수 호이스팅

```py
JavaScript 변수의 특이한 점은 나중에 선언된 변수를 참조할 수 있음

즉 JavaScript 변수가 어떤 의미에서 함수나 문의 최상단으로 "올려지는" (혹은 "끌어올려지는") 것을 말함. 하지만, 끌어올려진 변수는 undefined 값을 반환하며, 심지어 이 변수를 사용 혹은 참조한 후에 선언 및 초기화하더라도, 여전히 undefined를 반환.
```

- 호이스팅 예

```js
// Example 1

console.log(x === undefined); // true
var x = 3;

// Example 2

// undefined 값을 반환함.
var myvar = "my value";

(function () {
  console.log(myvar); // undefined
  var myvar = "local value";
})();

함수 내의 모든 var 문은 가능한 함수 상단 근처에 두는 것이 좋음. 이 방법은 코드를 더욱 명확하게 만들어줌.
```

## 📑 'this'는 무엇인가?

```js
greeting: function() {
    alert('Hi! i am ' + this.name.first + '.' )
}

this 키워드는 지금 동작하고 있는 코드를 가지고 있는 객체를 가르키며, 위에 예제에서 this는 person 객체와 동일.
```

- 왜 this를 쓰는가?

```js
this는 객체 멤버의 컨텍스트가 바뀌는 경우에도 언제나 정확한 값을 사용하게 해줌.

객체 리터럴을 직접 지정해서 사용하는 경우라면 그리 유용하지 않지만, 동적으로 객체를 생성하는 경우에는 매우 유용.
```

## 📑 화살표 함수

```js
화살표 함수 표현은 전통적인 함수표현의 간편한 대안.

(param1, param2, paramN) => { statements }
(param1, param2, paramN) => expression

var arr = [5, 6, 13, 0, 1]

var sum = arr.reduce((a, b) => a + b);
var even = arr.filter(v => v % 2 == 0);
var double = arr.map(v => v * 2);
```

## 📑 이벤트

- 구문

```js
addEventListener(type, listener);
addEventListener(type, listener, options);
addEventListener(type, listener, useCapture);
```

- 예제

```html
<table id="outside">
  <tr>
    <td id="t1">one</td>
  </tr>
  <tr>
    <td id="t2">two</td>
  </tr>
</table>
```

```js
// t2의 콘텐츠를 바꾸는 함수
function modifyText() {
  const t2 = document.getElementById("t2");
  if (t2.firstChild.nodeValue == "three") {
    t2.firstChild.nodeValue = "two";
  } else {
    t2.firstChild.nodeValue = "three";
  }
}

// 표에 이벤트 수신기 추가
const el = document.getElementById("outside");
el.addEventListener("click", modifyText, false);
```

## 🔎 내가 생각하는 중요한 기술

- 화살표 함수에 익숙해져야 간단한 문법을 작성할 수 있을 뿐 아니라, 코드 이해도와 해석에도 유용할 것 같다.

- 파이썬과는 다르게 웹페이지의 시멘틱을 조작할 수 있으니, 당분간 웹에 있어서는 javaScirpt가 필수적인 언어라는 생각이 든다.

- addEventListner를 이용하면 웹을 조금 더 동적으로 조작할 수 있을 것 같다.

## 💎 느낀점

- 익숙해지는게 무엇보다 중요한 것 같다.
- 처음에는 낯설어서 거부감이 들지만, 자꾸 보다보면은 익숙해지고 해석이 가능해지는 것 같다.
- 웹 프론트쪽은 javaScript를 안배울 수 없겠다는 생각이 들었다.
- 프론트뿐 아니라 node.js 등의 프레임워크들로 인해서 백엔드도 다룰 수 있으니 잘 알아두면 강점이 될 것 같다는 생각이 들었다.
